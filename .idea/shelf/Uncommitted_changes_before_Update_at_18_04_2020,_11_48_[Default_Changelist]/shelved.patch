Index: api/views.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import json\n\nfrom django.http import JsonResponse\nfrom rest_framework import status, mixins, generics\nfrom rest_framework.decorators import api_view\nfrom rest_framework.generics import get_object_or_404\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\nfrom yandex.Translater import Translater\nfrom api.serializers import *\nfrom .models import User as UserModel\n\n\ndef createUniquId():\n    # 8-numeric\n    return hash(str(uuid.uuid1())) % 100000000\n\n\nclass CreateStudySet(mixins.CreateModelMixin,\n                     generics.GenericAPIView):\n    serializer_class = StudySetsSerializer\n\n    def post(self, request, *args, **kwargs):\n        return self.create(request, *args, **kwargs)\n\n\nclass StudySetDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = StudySets.objects.all()\n    serializer_class = StudySetsSerializer\n\n\nclass GetDictationsOfCurrentUser(generics.ListAPIView):\n    serializer_class = DictationNamesSerializer\n\n    def get_queryset(self, user_email=None):\n        user_email = self.kwargs['user_email']\n        return Dictation.objects.filter(creator=user_email).order_by('-updated_at')\n\n\nclass GetStudySetsOfCurrentUser(generics.ListAPIView):\n    serializer_class = StudySetsSerializer\n\n    def get_queryset(self, user_email=None):\n        user_email = self.kwargs['user_email']\n        return StudySets.objects.filter(creator=user_email).order_by('-updated_at')\n\n\nclass User(APIView):\n\n    def get(self, request, email=None, format=None):\n        lookup = {'email': email}\n        vessel = get_object_or_404(UserModel, **lookup)\n        serializer = UserSerializer(vessel, context={'request': request})\n        return Response(serializer.data)\n\n\nclass CreateUser(mixins.CreateModelMixin,\n                 generics.GenericAPIView):\n    serializer_class = UserSerializer\n\n    def post(self, request, *args, **kwargs):\n        return self.create(request, *args, **kwargs)\n\n\nclass DictationView(APIView):\n    def get(self, request, code=None, mode=None, format=None):\n        lookup = {'pk': code} if mode == 'id' else {'code': code}\n        dictation = get_object_or_404(Dictation, **lookup)\n        serializer = SpecificDictationSerializer(dictation, context={'request': request})\n        return Response(serializer.data)\n\n    def post(self, request, format=None):\n        serializer = SpecificDictationSerializer(data=request.data)\n        if serializer.is_valid():\n            serializer.save(code=createUniquId())\n            return Response(serializer.data, status=status.HTTP_201_CREATED)\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n\n    def delete(self, request, pk=None, format=None):\n        dictation = Dictation.objects.get(pk=pk)\n        dictation.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n\n@api_view(['GET'])\ndef get_members_marks(request, dictation_id, mode):\n    global dictation\n    if mode == \"id\":\n        dictation = Dictation.objects.get(id=dictation_id)\n    elif mode == \"code\":\n        dictation = Dictation.objects.get(code=dictation_id)\n    if request.method == 'GET':\n        members_marks = []\n        dictation_marks = DictationMark.objects.filter(dictation=dictation)\n        for dictation_mark in dictation_marks:\n            members_marks.append({\"email\": dictation_mark.user.email, \"mark\": dictation_mark.mark})\n\n        return JsonResponse(members_marks, safe=False)\n\n\n@api_view(['PATCH'])\ndef update_user_mark(request, email):\n    import json\n\n    data = json.loads(request.data)\n    dictationId = data[\"dictation_id\"]\n    mark = data[\"mark\"]\n    user = User.objects.get(email=email)\n    dictation = Dictation.objects.get(id=dictationId)\n\n    try:\n        currentMark = DictationMark.objects.get(user=user, dictation=dictation)\n        currentMark.mark = mark\n    except DictationMark.DoesNotExist:\n        currentMark = DictationMark(user=user, dictation=dictation, mark=mark)\n\n    currentMark.save()\n\n    return Response(status=status.HTTP_200_OK)\n\n\n@api_view(['GET'])\ndef get_user_completed_dictations(request, email):\n    if request.method == 'GET':\n        dictation_marks = DictationMark.objects.filter(user=UserModel.objects.get(email=email)).order_by('-updated_at')[:20]\n        member_marks = []\n        for dictation_mark in dictation_marks:\n            member_marks.append({\"code\": dictation_mark.dictation.code,\n                                 \"name\": dictation_mark.dictation.name})\n\n        return JsonResponse(member_marks, safe=False)\n\n\n@api_view(['GET'])\ndef get_shared_studyset(request, creator, pk):\n    study_set = StudySets.objects.get(creator=creator, pk=pk)\n    if request.method == 'GET':\n        serializer = StudySetsSerializer(study_set)\n        return Response(serializer.data)\n\n\n@api_view(['POST'])\ndef create_study_set(request):\n    global serializer\n    if request.method == 'POST':\n        serializer = StudySetsSerializer(data=request.data)\n        if serializer.is_valid():\n            serializer.save()\n            return Response(serializer.data, status=status.HTTP_201_CREATED)\n    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n\n\n@api_view(['POST'])\ndef create_dictation(request):\n    global serializer\n    if request.method == 'POST':\n        serializer = SpecificDictationSerializer(data=request.data)\n        if serializer.is_valid():\n            serializer.save(code=createUniquId())\n            return Response(serializer.data, status=status.HTTP_201_CREATED)\n    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n\n\n@api_view(['POST', 'GET'])\ndef translate(request, from_lang, to_lang, mode='one'):\n    translater = Translater()\n\n    translater.set_key('trnsl.1.1.20200120T150252Z.3a85fe4899fc30b8.cb6bb06d018c3bb040233c26b981ba5b5e447520')\n    translater.set_from_lang(from_lang)\n    translater.set_to_lang(to_lang)\n\n    string_to_translate = request.data.get('nameValuePairs').get('words')\n\n    if mode == 'one':\n\n        translater.set_text(string_to_translate)\n\n        response = {\n            \"translation\": translater.translate()\n        }\n\n    elif mode == 'many':\n\n        translater.set_text(string_to_translate)\n\n        response = {'translation': translater.translate().replace(',', ';')}\n\n    return JsonResponse(response, status=status.HTTP_200_OK)\n\n\n@api_view(['POST'])\ndef finish_study_set(request, pk, mode):\n    study_set = StudySets.objects.get(pk=pk)\n\n    if mode == 'marked':\n        study_set_words = json.loads(study_set.marked_words)\n    else:\n        study_set_words = json.loads(study_set.words)\n\n    for study_set_word in study_set_words:\n        study_set_word[\"firstStage\"] = True\n        study_set_word[\"secondStage\"] = False\n        study_set_word[\"thirdStage\"] = False\n        study_set_word[\"forthStage\"] = False\n\n    if mode == 'marked':\n        study_set.marked_words = study_set_words\n    else:\n        study_set.words = study_set_words\n\n    study_set.studied = True\n\n    study_set.save()\n\n    return Response(status=status.HTTP_200_OK)\n\n\nclass RandomDictation(generics.GenericAPIView,\n                      mixins.ListModelMixin):\n\n    def get_queryset(self):\n        creator_name = self.kwargs['creator']\n        return Dictation.objects.exclude(creator=creator_name).order_by('?')[:1]\n\n    serializer_class = SpecificDictationSerializer\n\n    def get(self, request, *args, **kwargs):\n        return self.list(request, *args, **kwargs)\n\n\n@api_view(['POST'])\ndef clone_studyset(request, id, email):\n    studyset = StudySets.objects.get(pk=id)\n\n    cloned_studyset = StudySets.objects.filter(creator=email, words=studyset.words,\n                                               language_from=studyset.language_from,\n                                               language_to=studyset.language_to,\n                                               amount_of_words=studyset.amount_of_words,\n                                               name=studyset.name)\n\n    if cloned_studyset.exists():\n        return Response(cloned_studyset[0].pk, status=status.HTTP_200_OK)\n\n    if not studyset.creator == email and not cloned_studyset.exists():\n        studyset.pk = None\n\n        words = json.loads(studyset.words)\n\n        for word in words:\n            word[\"firstStage\"] = False\n            word[\"secondStage\"] = False\n            word[\"thirdStage\"] = False\n            word[\"forthStage\"] = False\n\n        studyset.words = words\n\n        studyset.creator = email\n        studyset.save()\n\n    return Response(studyset.pk, status=status.HTTP_200_OK)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- api/views.py	(revision 15758f19ed89f8a8af31525a749e24f51720bdce)
+++ api/views.py	(date 1587199550715)
@@ -104,7 +104,7 @@
     data = json.loads(request.data)
     dictationId = data["dictation_id"]
     mark = data["mark"]
-    user = User.objects.get(email=email)
+    user = UserModel.objects.get(email=email)
     dictation = Dictation.objects.get(id=dictationId)
 
     try:
